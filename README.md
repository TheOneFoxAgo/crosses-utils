# crosses-utils

Набор полезностей для ценителей крестиков. Что за крестики такие? Можете найти в книге **"Логика или фортуна"**, правда там они называются "Война вирусов".

# Использование:

Всего тут есть две полезные вещи `PlayerManager` и `IbtsBoard` (IBTS - Importance-based traverse strategy).

## PlayerManager

`PlayerManager` - это структура, позволяющая корректно изменять состояние игры. Она занимается изменением количества крестиков у игрока, переводом хода, окончанием игры и прочим. Она может изменять состояние игры в обе стороны, вперёд и назад. Таким образом, вам придётся думать только о том, как реализовать изменение игрового поля, а обо всём остальном позаботится PlayerManager.

## IbtsBoard

`IbtsBoard` - это трейт (интерфейс), при реализации которого, вам станут доступны 4 метода, которые нужно вызывать при замене:

1. `on_place_cross` - пустой клетки на крестик
2. `on_place_filled` - крестика на закрашенную клетку
3. `on_remove_filled` - закрашенной клетки на крестик
4. `on_remove_cross` - крестика на пустую клетку

После реализации этого интерфейса вам больше не придётся думать, когда начинать обход цепочки закрашенных клеток, всё сделают за вас четыре метода выше.

# Касательно "Зоны досягаемости"

Использования PlayerManager и IbtsBoard недостаточно для написания готовых к употреблению крестиков. Перед вами может встать два нетривиальных вопроса: "как обходить закрашенные клетки?" и "как отмечать зону досягаемости игрока (клетки, куда игрок может походить)?". На первый вопрос ответ легко можно найти в интернете по запросу *flood fill* или *seed fill*. А вот на второй вопрос вы ответы так просто не найдёте, так что я приведу их здесь.

## Как отмечать зону досягаемости?

### Ответ №0 - Никак

Если игрок тыкнул на клетку, то можно проверить, есть ли рядом его клетки, и если нет то ничего не делать.

**Плюсы**: Самый простой и экономичный подход в плане нагрузки на память.

**Минусы**: Не user-friendly. Пользователь не будет видеть куда он может тыкнуть. Конечно, это не проблема для опытных игроков, но к сожалению таких ~0,0000001% от популяции. Не понятно как просчитывать количество доступных ходов у игрока без полного обхода всех клеток игрока, или без дорогих проверок на активность смежных клеток при деактивации. Оба подхода к подсчёту больно бьют по процессору.

### Ответ №1 - Активна/Неактивна

Для каждой клетки можно хранить, является ли она активной(т.е. находящейся в зоне досягаемости) для игрока, который сейчас делает ход.

**Плюсы**: Очень простой подход. Экономично по памяти. Всего 1 бит для каждой клетки. Плюс, поскольку для реализации этого подхода придётся при каждой переходе очереди делать обход всех клеток нового игрока, то можно совместить активность с таблицей пройденных клеток и таким образов использовать 0 бит для каждой клетки (Выгоднее некуда).

**Минусы**: Сильно бьёт по процессору. Как уже говорилось, при каждой смене игрока придётся делать обход заново, то есть переделывать одну и ту же работу. Такая же проблема с подсчётом, как и №0.

### Ответ №3 - Активна/Неактивна для каждого игрока

Для каждой клетки можно хранить, является ли она активной для каждого игрока, отдельно.

**Плюсы**: Экономично по памяти. Всего 1 бит на каждого игрока. Более экономично по процессору. Не нужно постоянно пересчитывать зону досягаемости.

**Минусы**: Он тут один. Деактивация (Удаление клетки из зоны досягаемости) очень дорогая. Чтобы деактивировать клетку нужно просмотреть всех соседей (А их обычно 8). Таким образом, чтобы правильно обновить зону досягаемости при закраске крестика, придётся совершить ~64 доступа к памяти (Можно, конечно и соптимизировать, но это довольно нетривиальная задача). Я уж не говорю про выключение цепочки закрашенных клеток, про это лучше вообще не думать...

### Ответ №4 - Полный подсчёт

Для каждой клетки можно хранить количество активаций для каждого игрока. Если количество активаций равно нулю, то клетка неактивна.

**Плюсы**: Экономично по процессору. Нет необходимости смотреть соседей клетки при деактивации.

**Минусы**: Не очень экономично по памяти. В случае 8 соседей у клетки, для каждого игрока придётся выделить по 4 бита (На самом деле можно выделить 3 бита на каждого плюс 1 сверху, поскольку достичь 8 активаций может только один игрок. Однако, такой подход может ударить по процессору из-за дополнительных проверок). Нужно быть аккуратным при реализации обхода, так как каждую смежную цепочке клетку нужно будет пройти не 1 раз, как обычно, а столько, сколько у неё закрашенных соседей. Хотя, ничего сложного в этом нет.

### Ответ №5 - Перегрев

Для каждой клетки можно хранить маленький счётчик количества активаций для каждого игрока. Если счётчик оказывается превышен, то клетку отметить как перегретую. Если счётчик равен нулю, тогда если клетка перегрета, то посмотреть соседние клетки, и посчитать количество активаций, иначе клетка вне зоны досягаемости.

**Плюсы**: Экономично по памяти. В случае 8 соседей можно выделять по 2 бита на каждого игрока (Тут важно найти баланс, в случае 1 бита мы деградируем до №3, а в случае 3 бит лучше использовать №4). Не так сильно бьёт по процессору как №3 и ниже.

**Минусы**: Сложный алгоритм. Бьёт по процессору значительно сильнее №4.
